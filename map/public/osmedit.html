<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>OSM edit</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!--[if lt IE 7]><script src="http://openstreetmap.org/javascripts/pngfix.js" type="text/javascript"></script><![endif]--> <!-- thanks, microsoft! -->

    <meta NAME="description" Content="Différentes cartes pour contributeur à OpenStreetMap" />
    <meta NAME="keywords" Content="Carte, Map, OSM, OpenStreetMap, Edit" />
    <meta NAME="author" CONTENT="Stéphane Brunner" />
    <meta NAME="Copyright" CONTENT="Stéphane Brunner, 2011" />
    <meta NAME="Formatter" CONTENT="Geany" />
    <meta NAME="Generator" CONTENT="Geany" />
    <meta NAME="Robot" CONTENT="INDEX,FOLLOW" />
    <meta name="verify-v1" content="syP8XFMkXjlqcZAwWi+v+943YidZzaCgRsAWI1leDQE=" />

    <link rel="shortcut icon" href="http://map.stephane-brunner.ch/app/images/favicon.png" />

    <!--script type="text/javascript" src="http://map.stephane-brunner.ch/build/edit.js"></script>
    <script type="text/javascript" src="http://map.stephane-brunner.ch/OSM.js"></script>
    <script type="text/javascript" src="http://map.stephane-brunner.ch/OSMAPI.js"></script-->
    <script type="text/javascript" src="build/edit.js"></script>
    <script type="text/javascript" src="OSM.js"></script>
    <script type="text/javascript" src="OSMAPI.js"></script>
    <link type="text/css" rel="stylesheet" media="screen" href="http://map.stephane-brunner.ch/build/app.css">
  </head>
  <body>
    <div id="permalink" class="olControlPermalink olControlNoSelect" style="position: absolute;"></div>
    <script type="text/javascript">
/**
TODO

split and merge on snap point
add missing tools: delete
create new tools like:
 * squared
 * rounded
 * split
 * combined
 * relation editor
*/

        function crossWithSegment(seg, verts) {
            var result = [];

            for (var i=0, stop=verts.length-2; i<=stop; ++i) {
                var vert1 = verts[i];
                var vert2 = verts[i+1];
                var target = {x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y};
                point = OpenLayers.Geometry.segmentsIntersect(seg, target, {point: true});
                if (point) {
                    result.push(point);
                }
            }
            return result;
        }
        function crossing(source, target) {
            var results = [];
            if ((source instanceof OpenLayers.Geometry.LineString || source instanceof OpenLayers.Geometry.LinearRing) &&
                    (target instanceof OpenLayers.Geometry.LineString || target instanceof OpenLayers.Geometry.LinearRing)) {
                var verts = source.components;
                for (var i=0, stop=verts.length-2; i<=stop; ++i) {
                    var vert1 = verts[i];
                    var vert2 = verts[i+1];
                    var seg = {
                        x1: vert1.x, y1: vert1.y,
                        x2: vert2.x, y2: vert2.y
                    };
                    results = results.concat(crossWithSegment(seg, target.components));
                }
            } else {
                if ((source instanceof OpenLayers.Geometry.LineString || source instanceof OpenLayers.Geometry.LinearRing)
                        && target instanceof OpenLayers.Geometry.Collection) {
                    target.components.forEach(function(g) {
                        results = results.concat(crossing(source, g));
                    });
                }
                else if (source instanceof OpenLayers.Geometry.Collection) {
                    source.components.forEach(function(g) {
                        results = results.concat(crossing(g, target));
                    });
                }
            }
            return results;
        }

        window.onload = function() {
            Ext.BLANK_IMAGE_URL = "lib/ext/Ext/resources/images/default/s.gif";
            OpenLayers.ImgPath = "app/images/";
            OpenLayers.ProxyHost = "proxy.php?url="; // proxy is required here
            OpenLayers.Number.thousandsSeparator = ' ';
            OpenLayers.IMAGE_RELOAD_ATTEMPTS = 3;
            OpenLayers.ImgPath = "http://map.stephane-brunner.ch/app/images/oltheme/";
            Ext.QuickTips.init();
            var epsg900913 = new OpenLayers.Projection("EPSG:900913");
            var epsg4326 = new OpenLayers.Projection("EPSG:4326");
            var featuresDeleted = [];
            var strategie = new OpenLayers.Strategy.BBOX({
                ratio: 1.2,
                autoActivate: false,
                projection: epsg900913
            });
            var snapped;
            var snappedList = {};
            var snappedIndices = [];

            var blank = new OpenLayers.Layer.XYZ(OpenLayers.i18n("Blank"), "no.png", {
                    sphericalMercator: true,
                    wrapDateLine: true,
                    isBaseLayer: true,
                    numZoomLevels: 22
                });

            var osmTile = new OpenLayers.Layer.XYZ(OpenLayers.i18n("Mapnik"), [
                    "http://a.tile.openstreetmap.org/${z}/${x}/${y}.png",
                    "http://b.tile.openstreetmap.org/${z}/${x}/${y}.png",
                    "http://c.tile.openstreetmap.org/${z}/${x}/${y}.png"
                ], {
                    sphericalMercator: true,
                    wrapDateLine: true,
                    isBaseLayer: false,
                    transitionEffect: "resize",
                    numZoomLevels: 19,
                    attribution: "<a href='http://www.osm.org/'>CC by-sa - OSM</a>"
                });

            var styleMap = new OpenLayers.StyleMap();
            styleMap.styles["default"].addRules([new OpenLayers.Rule({
                symbolizer: {
                    pointRadius: 5,
                    fillOpacity: 0.6,
                    fillColor: 'lightgrey',
                    strokeColor: 'lightgrey',
                    strokeWidth: 3
                },
                filter: new OpenLayers.Filter()
            })]);
            styleMap.styles.select.addRules([new OpenLayers.Rule({
                symbolizer: {
                    pointRadius: 5,
                    fillOpacity: 0.6,
                    fillColor: 'blue',
                    strokeColor: 'blue',
                    strokeWidth: 3
                },
                filter: new OpenLayers.Filter()
            })]);
            styleMap = getJOSMLikeStyleMap(styleMap);
            styleMap = getOSMStyle(styleMap);
            var osm = new OpenLayers.Layer.Vector(OpenLayers.i18n("All features"), {
                projection: epsg900913,
                maxResolution: 1000000,
                strategies: [strategie],
                protocol: new OpenLayers.Protocol.OSMAPI({
                        url: "http://api.openstreetmap.org/api/0.6/map?",
//                        url: "http://api06.dev.openstreetmap.org/api/0.6/map?",
                    format: new OpenLayers.Format.OSM({
                        interestingTagsExclude: [],
                        internalProjection: epsg900913,
                        checkTags: false,
                        shareNode: true
                        /*,
                        relationsParsers: {
                            multipolygon: OpenLayers.Format.OSM.multipolygonParser,
                            boundary:     OpenLayers.Format.OSM.multipolygonParser,
                            route:        OpenLayers.Format.OSM.routeParser
                        }*/
                    })
                }),
                styleMap: styleMap,
                numZoomLevels: 26,
                attribution: "Data CC-By-SA by <a href='http://openstreetmap.org/'>OpenStreetMap</a>",
                getFeaturesBy: function(property, value) {
                    var features = [];
                    for(var i=0, len=this.features.length; i<len; ++i) {
                        if(this.features[i][property] == value) {
                            features.push(this.features[i]);
                        }
                    }
                    return features;
                }
            });
            var depandancies = {};
            var new_osm_id = -1;
            // true when we redraw depandancies
            var addDep = function (id1, id2) {
                if (depandancies[id1]) {
                    if (depandancies[id1].indexOf(id2) < 0) {
                        depandancies[id1].push(id2);
                    }
                }
                else {
                    depandancies[id1] = [id2];
                }
                if (depandancies[id2]) {
                    if (depandancies[id2].indexOf(id1) < 0) {
                        depandancies[id2].push(id1);
                    }
                }
                else {
                    depandancies[id2] = [id1];
                }
            };
            function snappedPoint(p) {
                var snapped = snappedList[p.x + 21000000 + p.y * 42000000];
                if (snapped) {
                    if (snapped && snapped.x == p.x && snapped.y == p.y) {
                        for (var i = 0, len = snapped.toFeatures.length ; i < len ; i++) {
                            var f = snapped.toFeatures[i];
                            var index = snapped.toIndices[i];
                            var oldIndex = index;
                            var dist = snapped.toIndicesDistance[i];
                            snappedIndices.forEach(function (a) {
                                if (a[0] < oldIndex) {
                                    index += 1;
                                }
                                else if (a[0] == oldIndex && a[1] < dist) {
                                    index += 1;
                                }
                            });
                            snappedIndices.push([oldIndex, dist]);
                            if (f.geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
                                var components = p.parent.components;
                                for (var i = 0, len = components.length ; i < len ; i++) {
                                    if (components[i].x == f.geometry.x && components[i].y == f.geometry.y) {
                                        components[i] = f.geometry;
                                    }
                                }
                                return false;
                            }
                            else if (f.geometry.CLASS_NAME == "OpenLayers.Geometry.Polygon") {
                                f.geometry.components[0].addComponent(p, index + 1);
                            }
                            else {
                                f.geometry.addComponent(p, index + 1);
                            }
                        }
                    }
                }
                return true;
            }
            function addFeatureToPoint(p) {
                if (!p.osm_id) {
                    if (snappedPoint(p)) {
                        var feat = new OpenLayers.Feature.Vector();
                        feat.geometry = p;
                        feat.osm_id = new_osm_id;
                        p.osm_id = new_osm_id;
                        new_osm_id -= 1;
                        feat.type = "node";
                        feat.fid = "node." + feat.osm_id;
                        feat.action = 'new';
                        osm.addFeatures([feat]);
                    }
                }
            }
            var updating = false;
            var update = function(e) {
                // var fl = e.features;
                // manage delete, ...
                if (!updating) {
                    updating = true;
                    if (e && e.feature) {
                        f = e.feature;
                        if (!f.osm_id) {
                            f.action = 'new';
                            f.osm_id = new_osm_id;
                            new_osm_id -= 1;
                            if (f.geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
                                f.type = 'node';
                                f.fid = "node." + f.osm_id;
                                f.geometry.osm_id = f.osm_id;
                                if (snapped && snapped.x == f.geometry.x && snapped.y == f.geometry.y) {
                                    snappedList[snapped.x + 21000000 + snapped.y * 42000000] = snapped;
                                    snappedPoint(f.geometry);
                                }
                            }
                            else {
                                f.type = 'way';
                                f.fid = "way." + f.osm_id;
                                f.geometry.getVertices().forEach(function(p) {
                                    addFeatureToPoint(p)
                                });
                            }
                        } else {
                            if (f.action != 'new') {
                                f.action = 'modified';
                            }
                            if (f.geometry.CLASS_NAME != "OpenLayers.Geometry.Point") {
                                f.geometry.getVertices().forEach(function(p) {
                                    if (!p.osm_id) {
                                        addFeatureToPoint(p)
                                    }
                                });
                            }
                        }
                    }
/*                    var dirty = false;
                    osm.features.sort(function (f1, f2) {
                        t1 = 0
                        if (f1.geometry.CLASS_NAME == 'OpenLayers.Geometry.Point') {
                            t1 = 3;
                        }
                        else if (f1.geometry.CLASS_NAME == 'OpenLayers.Geometry.LineString') {
                            t1 = 2
                        }
                        t2 = 0
                        if (f2.geometry.CLASS_NAME == 'OpenLayers.Geometry.Point') {
                            t2 = 3;
                        }
                        else if (f2.geometry.CLASS_NAME == 'OpenLayers.Geometry.LineString') {
                            t2 = 2
                        }
                        dirty = dirty || (t1 != t2);
                        return t2 - t1;
                    });*/
                    depandancies = {};
                    var fl = osm.features;
                    fl.forEach(function(f) {

                        if (f.type != 'node') {
                            f.geometry.getVertices().forEach(function(p) {
                                addDep(f.osm_id, p.osm_id);
                            });
                        }
                    });
                    snappedList = {};
                    snappedIndices = [];
/*                    if (dirty) {
                        osm.redraw();
                    }*/
                    updating = false;
                }
            };

            osm.events.register('sketchcomplete', osm, function(e) {
                update(e);
            });
            osm.events.register('sketchmodified', osm, function(e) {
                if (e.feature.geometry.CLASS_NAME != "OpenLayers.Geometry.Point") {
                    e.feature.geometry.getVertices().forEach(function(p) {
                        if (e.vertex.id != p.id && snapped && snapped.x == p.x && snapped.y == p.y) {
                            snappedList[snapped.x + 21000000 + snapped.y * 42000000] = snapped;
                        }
                    });
                }
            });
            osm.events.register('featuresadded', osm, function(e) {
                update(e);
            });
            osm.events.register('featuremodified', osm, function(e) {
                if (!e.feature.action) {
                    e.feature.action = 'modified';
                }
                update(e);
            });

            // create permalink provider
            var permalinkProvider = new GeoExt.state.PermalinkProvider();
            Ext.state.Manager.setProvider(permalinkProvider);
            // update link when state changes
            var onStatechange = function(provider) {
                var l = provider.getLink();
                Ext.get("permalink").update("<a href=" + l + ">Permalink</a>");
            };
            permalinkProvider.on({statechange: onStatechange});

            mapPanel = new GeoExt.MapPanel({
                region: "center",
                stateId: "m",
                tbar: [new Ext.Action({
                    text: "Pan",
                    toggleGroup: "tool",
                    pressed: true,
                }),
                new Ext.Action({
                    text: "Download",
                    handler: function() {
                        if (osm.getFeatureBy('action', 'modified') ||
                                osm.getFeatureBy('action', 'new') ||
                                osm.getFeatureBy('action', 'deleted')) {
                            alert(OpenLayers.i18n("Unable to up download new area on modified features"));
                        }
                        else {
                            depandancies = {};
                            strategie.update();
                        }
                    }
                }),
                new Ext.Action({
                    text: "Login",
                    handler: function() {
                        var win = new Ext.Window({
                            title: OpenLayers.i18n("Login"),
                            width: 840,
                            height: 400,
                            layout: 'fit',
                            html: '<iframe width="100%" height="100%" style="border: none;" src="http://stephane-brunner.ch/cgi-bin/osm.py?login=1"></iframe>',
                            defaultButtons: [new Ext.Action({
                                text: OpenLayers.i18n("Close"),
                                handler: function() {
                                    win.close();
                                    win.destroy();
                                }
                            })],
                            bbar: ['->', new Ext.Action({
                                text: OpenLayers.i18n("Close"),
                                handler: function() {
                                    win.close();
                                    win.destroy();
                                }
                            })]
                        });
                        win.show();
                    }
                }),
                new Ext.Action({
                    text: "Revert all",
                    handler: function() {
                        depandancies = {};
                        strategie.update();
                    }
                }),
                new Ext.Action({
                    text: "Save",
                    handler: function() {
                        var newNodes = [];
                        var newWays = [];
                        var todoPos = -1; // -1 mean not started
                        var todo = [];
                        var changeset;
                        var todoNext = function() {
                            todoPos += 1;
                            if (todoPos < todo.length) {
                                todo[todoPos]();
                            }
                        }
                        var finish = function() {
                            OpenLayers.Request.issue({
                                url: 'http://stephane-brunner.ch/cgi-bin/osm.py',
                                params: {
                                    'action': '/api/0.6/changeset/' + changeset + '/close',
                                    'method': 'PUT'
                                },
                                failure: function(r) { alert(OpenLayer.i18n("Unable to create a node.") + "\n" + r.statusText + "\n" + r.responseText); update(); }
                            });
                            update();
                        };
                        todo.push(function() {
                            OpenLayers.Request.GET({
                                url: "http://stephane-brunner.ch/cgi-bin/osm.py",
                                params: {
                                    'new': 'TestHTMLEditor'
                                },
                                success: function(r) {
                                    changeset = r.responseText.replace(/^\s+|\s+$/g, '');
                                    todoNext();
                                },
                                failure: function(r) { alert(OpenLayer.i18n("Unable to open changeset.") + "\n" + r.statusText + "\n" + r.responseText); }
                            });
                        });

                        osm.getFeaturesBy('action', 'new').forEach(function(f) {
                            if (f.type == 'node') {
                                newNodes.push(f);
                            }
                            else {
                                newWays.push(f);
                            }
                        });

                        var tagTemplate = new Ext.Template('<tag k="{k}" v="{v}" />');
                        tagTemplate.compile();
                        var nodeTemplate = new Ext.Template('<osm><node lon="{lon}" lat="{lat}" changeset="{changeset}">{tags}</node></osm>');
                        nodeTemplate.compile();
                        var sendNode = function(f, action, method) {
                            var nodes = '';
                            var tags = '';
                            for (p in f.properties) {
                                tags += tagTemplate.apply({'k': p, 'v': f.properties[p]});
                            }
                            var g = f.geometry.clone().transform(epsg900913, epsg4326);
                            OpenLayers.Request.issue({
                                url: 'http://stephane-brunner.ch/cgi-bin/osm.py',
                                params: {
                                    'method': method,
                                    'action': action,
                                    'data': nodeTemplate.apply({
                                        'lon': g.x,
                                        'lat': g.y,
                                        'changeset': changeset,
                                        'tags': tags
                                    })
                                },
                                success: function(r) {
                                    f.osm_id = r.responseText.replace(/^\s+|\s+$/g, '');
                                    f.geometry.osm_id = f.osm_id;
                                    f.fid = f.type + "." + f.osm_id;
                                    f.action = 'commited';
                                    todoNext();
                                },
                                failure: function(r) { alert(OpenLayer.i18n("Unable to create a node.") + "\n" + r.statusText + "\n" + r.responseText); finish(); }
                            });
                        };
                        newNodes.forEach(function(f) {
                            todo.push(function() {
                                sendNode(f, '/api/0.6/node/create', 'PUT')
                            });
                        });
                        var wayTemplate = new Ext.Template('<osm><way changeset="{changeset}">{nodes}{tags}</way></osm>');
                        wayTemplate.compile();
                        var nodeLinkTemplate = new Ext.Template('<nd ref="{ref}" />');
                        nodeLinkTemplate.compile();
                        var sendWay = function(f, action, method) {
                            var nodes = '';
                            f.geometry.getVertices().forEach(function(p) {
                                nodes += nodeLinkTemplate.apply({'ref': p.osm_id});
                            });
                            var tags = '';
                            for (p in f.properties) {
                                tags += tagTemplate.apply({'k': p, 'v': f.properties[p]});
                            }
                            OpenLayers.Request.issue({
                                url: 'http://stephane-brunner.ch/cgi-bin/osm.py',
                                params: {
                                    'method': method,
                                    'action': action,
                                    'data': wayTemplate.apply({
                                        'changeset': changeset,
                                        'nodes': nodes,
                                        'tags': tags
                                    })
                                },
                                success: function(r) {
                                    f.osm_id = r.responseText.replace(/^\s+|\s+$/g, '');
                                    f.geometry.osm_id = f.osm_id;
                                    f.fid = f.type + "." + f.osm_id;
                                    f.action = 'commited';
                                    todoNext();
                                },
                                failure: function(r) { alert(OpenLayer.i18n("Unable to create a node.") + "\n" + r.statusText + "\n" + r.responseText); finish(); }
                            });
                        };
                        newWays.forEach(function(f) {
                            todo.push(function() {
                                sendWay(f, '/api/0.6/way/create', 'PUT');
                            });
                        });
                        osm.getFeaturesBy('action', 'modified').forEach(function(f) {
                            if (f.type == 'node') {
                                todo.push(function() {
                                    sendNode(f, '/api/0.6/node/#' + f.osm_id, 'PUT');
                                });
                            }
                            else {
                                todo.push(function() {
                                    sendWay(f, '/api/0.6/way/#' + f.osm_id, 'PUT');
                                });
                            }
                        });
                        featuresDeleted.forEach(function(f) {
                            todo.push(function() {
                                OpenLayers.Request.issue({
                                    url: 'http://stephane-brunner.ch/cgi-bin/osm.py',
                                    params: {
                                        'method': 'DELETE',
                                        'action': '/api/0.6/' + f.type + '/#' + f.osm_id
                                    },
                                    success: function(r) {
                                        featuresDeleted = featuresDeleted.splice(featuresDeleted.indexOf(f), 1);
                                        todoNext();
                                    },
                                    failure: function(r) { alert(OpenLayer.i18n("Unable to create a node.") + "\n" + r.statusText + "\n" + r.responseText); finish(); }
                                });
                            });
                        });
                        todo.push(finish);

                        todoNext();
                    }
                })],
                layers: [blank, osmTile, osm],
                map: {
//                    fractionalZoom: true,
                    theme: null
                }
            });
            mapPanel.on('ready', function() {
                strategie.update();
            });
            mapPanel.map.addControl(new OpenLayers.Control.PanZoomBar({panIcons: false, zoomWorldIcon: false}));
            var snap = new OpenLayers.Control.Snapping({
                layer: osm,
                targets: [osm],
                testTarget: function(target, loc) {
                    var resolution = this.layer.map.getResolution();
                    if ("minResolution" in target) {
                        if (resolution < target.minResolution) {
                            return null;
                        }
                    }
                    if ("maxResolution" in target) {
                        if (resolution >= target.maxResolution) {
                            return null;
                        }
                    }
                    var tolerance = {
                        node: this.getGeoTolerance(target.nodeTolerance, resolution),
                        vertex: this.getGeoTolerance(target.vertexTolerance, resolution),
                        edge: this.getGeoTolerance(target.edgeTolerance, resolution)
                    };
                    // this could be cached if we don't support setting tolerance values directly
                    var maxTolerance = Math.max(
                        tolerance.node, tolerance.vertex, tolerance.edge
                    );
                    var result = {
                        rank: Number.POSITIVE_INFINITY, dist: Number.POSITIVE_INFINITY
                    };
                    var eligible = false;
                    var features = target.layer.features;
                    var feature, type, vertices, vertex, closest, dist, found;
                    var numTypes = this.precedence.length;
                    var ll = new OpenLayers.LonLat(loc.x, loc.y);
                    for (var i=0, len=features.length; i<len; ++i) {
                        feature = features[i];
                        if (feature !== this.feature && !feature._sketch &&
                           feature.state !== OpenLayers.State.DELETE &&
                           (!target.filter || target.filter.evaluate(feature))) {
                            if (feature.atPoint(ll, maxTolerance, maxTolerance)) {
                                for (var j=0, stop=Math.min(result.rank+1, numTypes); j<stop; ++j) {
                                    type = this.precedence[j];
                                    if (target[type]) {
                                        if (type === "edge") {
                                            closest = feature.geometry.distanceTo(loc, {details: true});
                                            dist = closest.distance;
                                            var pointFind = false;

                                            if (eligible && result.toFeatures.length == 1) {
                                                points = crossing(result.toFeatures[0].geometry, feature.geometry);
                                                points.forEach(function(point) {
                                                    var pointClosest = point === true ? closest : point.distanceTo(loc, {details: true});
                                                    var pointDist = pointClosest.distance;
                                                    if (pointDist <= tolerance['node']) {
                                                        result = {
                                                            toFeatures: [feature, result.toFeatures[0]],
                                                            toIndices: [closest.index, result.toIndices[0]],
                                                            toIndicesDistance: [closest.indexDistance, result.toIndicesDistance[0]],
                                                            rank: j, dist: dist,
                                                            x: pointClosest.x0, y: pointClosest.y0 // closest coords on feature
                                                        };
                                                        eligible = true;
                                                        pointFind = true;
                                                    }
                                                });
                                            }
                                            if (pointFind) {
                                                // don't look for lower precedence types for this feature
                                                break;
                                            }

                                            if (dist <= tolerance[type] && dist < result.dist) {
                                                result = {
                                                    toFeatures: [feature],
                                                    toIndices: [closest.index],
                                                    toIndicesDistance: [closest.indexDistance],
                                                    rank: j, dist: dist,
                                                    x: closest.x0, y: closest.y0 // closest coords on feature
                                                };
                                                eligible = true;
                                            }
                                        } else {
                                            // look for nodes or vertices
                                            vertices = feature.geometry.getVertices(type === "node");
                                            found = false;
                                            for (var k=0, klen=vertices.length; k<klen; ++k) {
                                                vertex = vertices[k];
                                                dist = vertex.distanceTo(loc);
                                                if (dist <= tolerance[type] &&
                                                        (j < result.rank || (j === result.rank && dist < result.dist))) {
                                                    result = {
                                                        toFeatures: [feature],
                                                        toIndices: [k],
                                                        toIndicesDistance: [0],
                                                        rank: j, dist: dist,
                                                        x: vertex.x, y: vertex.y
                                                    };
                                                    eligible = true;
                                                    found = true;
                                                }
                                            }
                                            if (found) {
                                                // don't look for lower precedence types for this feature
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (eligible) {
                        snapped = result;
                    }
                    return eligible ? result : null;
                }
            });
            snap.activate();
            
            mainPanel = new Ext.Viewport({
                layout: "fit",
                hideBorders: true,
                items: [{
                    layout: "border",
                    deferredRender: false,
                    items: [mapPanel]
                }]
            });
            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "Point",
                toggleGroup: "tool",
                control: new OpenLayers.Control.DrawFeature(osm, OpenLayers.Handler.Point),
                map: mapPanel.map
            }));
            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "Path",
                toggleGroup: "tool",
                control: new OpenLayers.Control.DrawFeature(osm, OpenLayers.Handler.Path),
                map: mapPanel.map
            }));
            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "Polygon",
                toggleGroup: "tool",
                control: new OpenLayers.Control.DrawFeature(osm, OpenLayers.Handler.Polygon),
                map: mapPanel.map
            }));
            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "DragFeature",
                toggleGroup: "tool",
                map: mapPanel.map,
                control: new OpenLayers.Control.DragFeature(osm, {
                    onDrag: function(f) {
                        if (f.type == 'node' && !f.action) {
                            f.action = 'modified';
                        }
                        var dep = depandancies[f.osm_id];
                        if (dep) {
                            for (var i = 0, leni = dep.length; i < leni; i++) {
                                var id = dep[i];
                                var fd = osm.getFeatureBy('osm_id', id);
                                osm.drawFeature(fd);
                                if (fd.type == 'node') {
                                    if (!fd.action) {
                                        fd.action = 'modified';
                                    }
                                    var dep2 = depandancies[id];
                                    if (dep2) {
                                        for (var j = 0, lenj = dep2.length; j < lenj; j++) {
                                            var fd2 = osm.getFeatureBy('osm_id', dep2[j]);
                                            osm.drawFeature(fd2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                })
            }));
            var modifyFeature = new OpenLayers.Control.ModifyFeature(osm, {});
            modifyFeature.selectControl.onUnselect = function(f) {
                f.geometry.getVertices().forEach(function(p) {
                    osm.drawFeature(osm.getFeatureBy('osm_id', p.osm_id));
                });
            }
            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "ModifyFeature",
                toggleGroup: "tool",
                desable: true,
                control: modifyFeature,
                map: mapPanel.map
            }));
/*            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "Rotate - Zoom",
                toggleGroup: "tool",
                desable: true,
                control: new OpenLayers.Control.TransformFeature(osm, {preserveAspectRatio: true}),
                map: mapPanel.map
            }));
            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "Delete",
                toggleGroup: "tool",
                desable: true,
                control: new OpenLayers.Control.SelectFeature(osm, {
                    onBeforeSelect: function(f) {
                    }
                }),
                map: mapPanel.map
            }));*/
            var editSelectFeature = new OpenLayers.Control.SelectFeature(osm, {
                onUnSelect: function(f) {
                }
            });
            editSelectFeature.onSelect = function(f) {
                var Property = Ext.data.Record.create([
                    {name: 'property'},
                    {name: 'value'}
                ]);
                var data = [];
                for (var property in f.attributes) {
                    data.push([property, f.attributes[property]]);
                }
                var store = new Ext.data.ArrayStore({
                    autoDestroy: true,
                    storeId: 'myStore',
                    idIndex: 0,
                    fields: ['property', 'value'],
                    data: data
                });
                var grid = new Ext.grid.EditorGridPanel({
                    store: store,
                    colModel: new Ext.grid.ColumnModel({
                        defaults: {
                            width: 120,
                            editor: new Ext.form.TextField()
                        },
                        columns: [
                            {header: 'Property', dataIndex: 'property'},
                            {header: 'Value', dataIndex: 'value'}
                        ]
                    }),
                    viewConfig: {
                        forceFit: true
                    },
                    sm: new Ext.grid.RowSelectionModel({singleSelect:true}),
                    hideHeaders: true,
                    boxMinHeight: 150,
                    bbar: ['->']
                });
                grid.on('afteredit', function(e) {
                    if (e.field == 'property' && e.originalValue !== '') {
                        delete f.attributes[e.originalValue]
                    }
                    else if (e.field == 'value' && e.record.data.value == '') {
                        delete f.attributes[e.record.data.property]
                    }
                    if (e.record.data.property != '' && e.record.data.value != '') {
                        f.attributes[e.record.data.property] = e.record.data.value;
                    }
                });
                grid.getBottomToolbar().add({
                    text   : "Delete",
                    handler: function() {
                        store.remove(grid.getSelectionModel().getSelected());
                        grid.getView().refresh();
                    }
                });
                grid.getBottomToolbar().add({
                    text   : "Add",
                    handler: function() {
                        var index = store.getCount();
                        store.insert(index, new Property({property: '', value: ''}));
                        grid.getView().refresh();
                        grid.getSelectionModel().selectRow(index);
                    }
                });
                var postFix = "";
                if (f.attributes.name) {
                    postFix = " - " + f.attributes.name;
                }
                var popup = new GeoExt.Popup({
                    title: "Properties" + postFix,
                    location: f.geometry.getCentroid(),
                    width: 300,
                    layout: 'fit',
                    collapsible: false,
                    map: mapPanel.map,
                    items: [grid]
                });
                popup.on('close', function() {
                    grid.stopEditing();
                    editSelectFeature.unselectAll();
                });
                popup.show();
            }
            mapPanel.getTopToolbar().addButton(new GeoExt.Action({
                text: "Edit",
                toggleGroup: "tool",
                desable: true,
                control: editSelectFeature,
                map: mapPanel.map
            }));
        };
    </script>

      <!-- phpmyvisites -->
      <a href="http://www.phpmyvisites.net/" title="Free web analytics, website statistics"
      onclick="window.open(this.href);return(false);"><script type="text/javascript">
      <!--
      var a_vars = Array();
      var pagename='The map';

      var phpmyvisitesSite = 1;
      var phpmyvisitesURL = "http://www.stephane-brunner.ch/phpmv2/phpmyvisites.php";
      //-->
      </script>
      <script language="javascript" src="http://www.stephane-brunner.ch/phpmv2/phpmyvisites.js" type="text/javascript"></script>
      <object><noscript><p>Free web analytics, website statistics
      <img src="http://www.stephane-brunner.ch/phpmv2/phpmyvisites.php" alt="Statistics" style="border:0" />
      </p></noscript></object></a>
      <!-- /phpmyvisites -->
</body>
</html>

